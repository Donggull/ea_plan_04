/**
 * React 19 DevTools Profiler 활용 유틸리티
 * 성능 모니터링 및 최적화 도구
 */
import { Profiler, ProfilerOnRenderCallback, ReactNode, useState, useEffect, useMemo } from 'react'\n\n// 성능 메트릭 타입\ninterface PerformanceMetric {\n  id: string\n  phase: 'mount' | 'update'\n  actualDuration: number\n  baseDuration: number\n  startTime: number\n  commitTime: number\n  interactions: Set<any>\n  timestamp: number\n}\n\n// 성능 통계\ninterface PerformanceStats {\n  totalRenders: number\n  averageRenderTime: number\n  slowestRender: number\n  fastestRender: number\n  mountTime: number\n  updateTime: number\n  lastRender: number\n}\n\n// 성능 임계값\nconst PERFORMANCE_THRESHOLDS = {\n  SLOW_RENDER: 16, // 16ms (60fps 기준)\n  VERY_SLOW_RENDER: 100, // 100ms\n  WARNING_RENDER_COUNT: 10, // 10회 이상 렌더링 시 경고\n}\n\n// 성능 데이터 저장소\nclass PerformanceStore {\n  private static instance: PerformanceStore\n  private metrics: Map<string, PerformanceMetric[]> = new Map()\n  private stats: Map<string, PerformanceStats> = new Map()\n  private listeners: Map<string, Array<(stats: PerformanceStats) => void>> = new Map()\n\n  static getInstance(): PerformanceStore {\n    if (!this.instance) {\n      this.instance = new PerformanceStore()\n    }\n    return this.instance\n  }\n\n  addMetric(metric: PerformanceMetric) {\n    const { id } = metric\n    \n    if (!this.metrics.has(id)) {\n      this.metrics.set(id, [])\n    }\n    \n    const componentMetrics = this.metrics.get(id)!\n    componentMetrics.push(metric)\n    \n    // 최대 100개 메트릭만 저장 (메모리 관리)\n    if (componentMetrics.length > 100) {\n      componentMetrics.shift()\n    }\n    \n    this.updateStats(id)\n    this.notifyListeners(id)\n  }\n\n  private updateStats(id: string) {\n    const componentMetrics = this.metrics.get(id) || []\n    if (componentMetrics.length === 0) return\n\n    const renderTimes = componentMetrics.map(m => m.actualDuration)\n    const mountMetrics = componentMetrics.filter(m => m.phase === 'mount')\n    const updateMetrics = componentMetrics.filter(m => m.phase === 'update')\n\n    const stats: PerformanceStats = {\n      totalRenders: componentMetrics.length,\n      averageRenderTime: renderTimes.reduce((a, b) => a + b, 0) / renderTimes.length,\n      slowestRender: Math.max(...renderTimes),\n      fastestRender: Math.min(...renderTimes),\n      mountTime: mountMetrics.length > 0 ? mountMetrics[0].actualDuration : 0,\n      updateTime: updateMetrics.length > 0 ? \n        updateMetrics.reduce((a, b) => a + b.actualDuration, 0) / updateMetrics.length : 0,\n      lastRender: componentMetrics[componentMetrics.length - 1].actualDuration\n    }\n\n    this.stats.set(id, stats)\n  }\n\n  getStats(id: string): PerformanceStats | undefined {\n    return this.stats.get(id)\n  }\n\n  getAllStats(): Record<string, PerformanceStats> {\n    const result: Record<string, PerformanceStats> = {}\n    this.stats.forEach((stats, id) => {\n      result[id] = stats\n    })\n    return result\n  }\n\n  subscribe(id: string, callback: (stats: PerformanceStats) => void): () => void {\n    if (!this.listeners.has(id)) {\n      this.listeners.set(id, [])\n    }\n    \n    const componentListeners = this.listeners.get(id)!\n    componentListeners.push(callback)\n    \n    return () => {\n      const index = componentListeners.indexOf(callback)\n      if (index > -1) {\n        componentListeners.splice(index, 1)\n      }\n    }\n  }\n\n  private notifyListeners(id: string) {\n    const listeners = this.listeners.get(id) || []\n    const stats = this.stats.get(id)\n    \n    if (stats) {\n      listeners.forEach(listener => listener(stats))\n    }\n  }\n\n  exportData(): string {\n    const data = {\n      timestamp: new Date().toISOString(),\n      metrics: Object.fromEntries(this.metrics),\n      stats: Object.fromEntries(this.stats)\n    }\n    \n    return JSON.stringify(data, null, 2)\n  }\n\n  clear() {\n    this.metrics.clear()\n    this.stats.clear()\n    this.listeners.clear()\n  }\n}\n\nconst performanceStore = PerformanceStore.getInstance()\n\n// React Profiler 래퍼 컴포넌트\ninterface ReactProfilerProps {\n  id: string\n  children: ReactNode\n  enabled?: boolean\n  onSlowRender?: (id: string, duration: number) => void\n  threshold?: number\n}\n\nexport function ReactProfiler({\n  id,\n  children,\n  enabled = process.env.NODE_ENV === 'development',\n  onSlowRender,\n  threshold = PERFORMANCE_THRESHOLDS.SLOW_RENDER\n}: ReactProfilerProps) {\n  const onRender: ProfilerOnRenderCallback = (\n    id,\n    phase,\n    actualDuration,\n    baseDuration,\n    startTime,\n    commitTime,\n    interactions\n  ) => {\n    if (!enabled) return\n\n    const metric: PerformanceMetric = {\n      id,\n      phase,\n      actualDuration,\n      baseDuration,\n      startTime,\n      commitTime,\n      interactions,\n      timestamp: Date.now()\n    }\n\n    performanceStore.addMetric(metric)\n\n    // 느린 렌더링 감지\n    if (actualDuration > threshold) {\n      console.warn(\n        `Slow render detected in \"${id}\": ${actualDuration.toFixed(2)}ms (threshold: ${threshold}ms)`,\n        {\n          phase,\n          actualDuration,\n          baseDuration,\n          interactions: Array.from(interactions)\n        }\n      )\n      \n      onSlowRender?.(id, actualDuration)\n    }\n  }\n\n  if (!enabled) {\n    return <>{children}</>\n  }\n\n  return (\n    <Profiler id={id} onRender={onRender}>\n      {children}\n    </Profiler>\n  )\n}\n\n// 성능 모니터링 훅\nexport function usePerformanceStats(componentId: string) {\n  const [stats, setStats] = useState<PerformanceStats | undefined>()\n\n  useEffect(() => {\n    const unsubscribe = performanceStore.subscribe(componentId, setStats)\n    \n    // 초기 데이터 로드\n    const initialStats = performanceStore.getStats(componentId)\n    if (initialStats) {\n      setStats(initialStats)\n    }\n\n    return unsubscribe\n  }, [componentId])\n\n  return stats\n}\n\n// 성능 경고 시스템\nexport function usePerformanceWarnings(componentId: string, options: {\n  slowRenderThreshold?: number\n  maxRenderCount?: number\n} = {}) {\n  const {\n    slowRenderThreshold = PERFORMANCE_THRESHOLDS.SLOW_RENDER,\n    maxRenderCount = PERFORMANCE_THRESHOLDS.WARNING_RENDER_COUNT\n  } = options\n\n  const stats = usePerformanceStats(componentId)\n  \n  const warnings = useMemo(() => {\n    if (!stats) return []\n    \n    const warnings: string[] = []\n    \n    if (stats.averageRenderTime > slowRenderThreshold) {\n      warnings.push(`평균 렌더링 시간이 느림: ${stats.averageRenderTime.toFixed(2)}ms`)\n    }\n    \n    if (stats.slowestRender > PERFORMANCE_THRESHOLDS.VERY_SLOW_RENDER) {\n      warnings.push(`매우 느린 렌더링 감지: ${stats.slowestRender.toFixed(2)}ms`)\n    }\n    \n    if (stats.totalRenders > maxRenderCount) {\n      warnings.push(`과도한 렌더링: ${stats.totalRenders}회`)\n    }\n    \n    return warnings\n  }, [stats, slowRenderThreshold, maxRenderCount])\n\n  return {\n    stats,\n    warnings,\n    hasWarnings: warnings.length > 0\n  }\n}\n\n// 성능 대시보드 컴포넌트\nexport function PerformanceDashboard() {\n  const [allStats, setAllStats] = useState<Record<string, PerformanceStats>>({})\n  const [isVisible, setIsVisible] = useState(false)\n\n  useEffect(() => {\n    const updateStats = () => {\n      setAllStats(performanceStore.getAllStats())\n    }\n\n    const interval = setInterval(updateStats, 1000)\n    updateStats() // 초기 로드\n\n    return () => clearInterval(interval)\n  }, [])\n\n  if (!isVisible || process.env.NODE_ENV !== 'development') {\n    return (\n      <button\n        onClick={() => setIsVisible(true)}\n        className=\"fixed bottom-4 right-4 bg-blue-500 text-white p-2 rounded-full shadow-lg z-50\"\n        title=\"성능 대시보드 열기\"\n      >\n        📊\n      </button>\n    )\n  }\n\n  const exportData = () => {\n    const data = performanceStore.exportData()\n    const blob = new Blob([data], { type: 'application/json' })\n    const url = URL.createObjectURL(blob)\n    const a = document.createElement('a')\n    a.href = url\n    a.download = `performance-data-${new Date().toISOString().split('T')[0]}.json`\n    a.click()\n    URL.revokeObjectURL(url)\n  }\n\n  return (\n    <div className=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50\">\n      <div className=\"bg-white dark:bg-gray-800 rounded-lg p-6 max-w-4xl max-h-[80vh] overflow-y-auto\">\n        <div className=\"flex justify-between items-center mb-4\">\n          <h2 className=\"text-xl font-bold\">성능 대시보드</h2>\n          <div className=\"flex gap-2\">\n            <button\n              onClick={exportData}\n              className=\"bg-green-500 text-white px-3 py-1 rounded text-sm\"\n            >\n              내보내기\n            </button>\n            <button\n              onClick={() => {\n                performanceStore.clear()\n                setAllStats({})\n              }}\n              className=\"bg-red-500 text-white px-3 py-1 rounded text-sm\"\n            >\n              초기화\n            </button>\n            <button\n              onClick={() => setIsVisible(false)}\n              className=\"bg-gray-500 text-white px-3 py-1 rounded text-sm\"\n            >\n              닫기\n            </button>\n          </div>\n        </div>\n\n        <div className=\"space-y-4\">\n          {Object.entries(allStats).map(([componentId, stats]) => (\n            <div key={componentId} className=\"border rounded p-4\">\n              <h3 className=\"font-semibold mb-2\">{componentId}</h3>\n              <div className=\"grid grid-cols-2 md:grid-cols-4 gap-4 text-sm\">\n                <div>\n                  <span className=\"text-gray-600\">총 렌더링:</span>\n                  <span className=\"ml-2 font-mono\">{stats.totalRenders}</span>\n                </div>\n                <div>\n                  <span className=\"text-gray-600\">평균 시간:</span>\n                  <span className={`ml-2 font-mono ${\n                    stats.averageRenderTime > PERFORMANCE_THRESHOLDS.SLOW_RENDER\n                      ? 'text-red-600'\n                      : 'text-green-600'\n                  }`}>\n                    {stats.averageRenderTime.toFixed(2)}ms\n                  </span>\n                </div>\n                <div>\n                  <span className=\"text-gray-600\">최대 시간:</span>\n                  <span className={`ml-2 font-mono ${\n                    stats.slowestRender > PERFORMANCE_THRESHOLDS.VERY_SLOW_RENDER\n                      ? 'text-red-600'\n                      : stats.slowestRender > PERFORMANCE_THRESHOLDS.SLOW_RENDER\n                      ? 'text-yellow-600'\n                      : 'text-green-600'\n                  }`}>\n                    {stats.slowestRender.toFixed(2)}ms\n                  </span>\n                </div>\n                <div>\n                  <span className=\"text-gray-600\">마지막 렌더링:</span>\n                  <span className=\"ml-2 font-mono\">\n                    {stats.lastRender.toFixed(2)}ms\n                  </span>\n                </div>\n              </div>\n            </div>\n          ))}\n        </div>\n\n        {Object.keys(allStats).length === 0 && (\n          <p className=\"text-center text-gray-500 py-8\">\n            성능 데이터가 없습니다. 컴포넌트를 사용해보세요.\n          </p>\n        )}\n      </div>\n    </div>\n  )\n}\n\n// HOC 형태의 프로파일러\nexport function withProfiler<P extends object>(\n  Component: React.ComponentType<P>,\n  id?: string,\n  options?: Omit<ReactProfilerProps, 'children' | 'id'>\n) {\n  const WrappedComponent = (props: P) => {\n    const componentId = id || Component.displayName || Component.name || 'UnknownComponent'\n    \n    return (\n      <ReactProfiler id={componentId} {...options}>\n        <Component {...props} />\n      </ReactProfiler>\n    )\n  }\n\n  WrappedComponent.displayName = `withProfiler(${Component.displayName || Component.name})`\n\n  return WrappedComponent\n}\n\n// 성능 최적화 제안 시스템\nexport function usePerformanceRecommendations(componentId: string) {\n  const stats = usePerformanceStats(componentId)\n  \n  const recommendations = useMemo(() => {\n    if (!stats) return []\n    \n    const recommendations: string[] = []\n    \n    if (stats.averageRenderTime > PERFORMANCE_THRESHOLDS.SLOW_RENDER) {\n      recommendations.push('React.memo() 사용을 고려해보세요')\n      recommendations.push('useMemo() 또는 useCallback() 으로 값을 메모이제이션하세요')\n    }\n    \n    if (stats.totalRenders > PERFORMANCE_THRESHOLDS.WARNING_RENDER_COUNT) {\n      recommendations.push('불필요한 리렌더링을 방지하세요')\n      recommendations.push('useState의 함수형 업데이트를 사용하세요')\n    }\n    \n    if (stats.slowestRender > PERFORMANCE_THRESHOLDS.VERY_SLOW_RENDER) {\n      recommendations.push('컴포넌트를 더 작은 단위로 분리하세요')\n      recommendations.push('React.lazy()로 코드 스플리팅을 고려하세요')\n    }\n    \n    return recommendations\n  }, [stats])\n\n  return recommendations\n}\n\nexport { performanceStore }"